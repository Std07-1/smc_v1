# Deprecation policy (Compat + removal)

Цей документ описує мінімальну, але жорстку політику сумісності (compat) та видалення застарілого API в репозиторії.

> Статус (2025-12-18): у репо **немає активних compat-модулів**. Політика лишається як рейка на майбутнє — щоб тимчасові фасади, якщо їх доведеться вводити, мали TTL і не перетворювались на «другий шлях».

## 1) Визначення

**Compat façade** — thin-модуль/тонкий шар, який існує лише для підтримки *старих шляхів імпорту* або *старих назв* під час міграції на SSOT.

Ознаки compat façade:

- робить **реекспорт** канонічних символів з SSOT (`core/*`), без власної бізнес-логіки;
- не змінює runtime shape/payload;
- не тягне заборонених залежностей (правило залежностей має виконуватися).

## 2) Маркування compat

Кожен compat-модуль має мати:

- модульний докстрінг з явним словом `Compat`;
- константу `REMOVE_AFTER` (рядок) у форматі **дата або версія**:
  - дата: `YYYY-MM-DD` (переважно), або
  - версія: `vX.Y`.

Приклад (мінімум):

```python
"""Compat wrapper для старих імпортів.

REMOVE_AFTER: 2026-02-01
"""

REMOVE_AFTER = "2026-02-01"
```

## 3) Removal gates (коли можна видаляти)

Compat можна видаляти лише коли виконані всі умови:

- **0 usages у prod+tests**: у репо немає імпортів цього compat-шляху;
- **гейти зелені**:
  - `python -m pre_commit run --all-files`
  - `python tools/audit_repo_report.py`
  - `python -m pytest -q`

## 4) TTL / політика терміну життя

- За замовчуванням TTL compat — **до 6–8 тижнів** (або одна узгоджена версія), після чого має бути або:
  - видалення (якщо usages=0), або
  - явне продовження `REMOVE_AFTER` з коротким поясненням у PR/міграційному логу.

## 5) Заборони та рейки

- Заборонено додавати нові імпорти зі старих compat-шляхів всередині репо.
- Заборонено додавати “нові compat” без маркування `REMOVE_AFTER`.
- Рекомендований підхід: дешеві `forbidden_strings` рейки в `tools/import_rules.toml` для блокування повернення legacy імпортів.
