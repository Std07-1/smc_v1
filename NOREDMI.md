# План реорганізації під SMC (FXCM → UnifiedDataStore → SMC core)

## Контекст і ціль зараз

- FXCM_FAST_SYMBOLS — це контракт потреб SMC, а не просто whitelist у конекторі.
- UnifiedDataStore має бути робочою пам'яттю SMC/UI_v2: тільки потрібні символи/TF і мінімальна глибина для якісного аналізу.
- Конектор може стрімити ширший універсум, але SMC повинна бачити/сплачувати лише FXCM_FAST_SYMBOLS з погодженим обсягом історії та частотою.
- Warmup — це gate якості: поки немає достатньої глибини/цілісності історії, пара (symbol, tf) не переходить у LIVE і не публікується в UI.

### Уточнення про FXCM-конектор

- Конектор — окрема система в іншому середовищі, зі своїм доступом до брокера, власним кешем/вирівнюванням історії (до ~3000 свічок) та HMAC/каналами. У цьому репозиторії ми його не будуємо й не дублюємо.
- Завдання SMC: формулювати contract-of-needs і споживати лише дані, що відповідають контракту. Будь-які інші функції конектора (архів, додаткові символи) — поза межами smc_v1.

## Принципи

- "Contract of needs" живе на боці SMC (datastore.yaml/config) і диктує вимоги до стріму/історії.
- Інверсія залежності: конектор та інжестор читають контракт і підлаштовують стрім, а не навпаки.
- UnifiedDataStore тримає тільки те, що споживає SMC/UI_v2; для сторонніх символів — максимум короткий буфер для діагностики.
- Scheduler мислиться з бюджетом: черга задач по (symbol, tf), м'який ліміт завдань на цикл, керований перехід COLD→WARMUP→LIVE.

## План робіт (етапи й обсяг)

1) **Специфікація contract-of-needs (S)**
   - Формат у config/datastore.yaml (ключ `smc_universe` або `fxcm_contract`): `version: <int|string>` + `symbols: [{id, tfs: [1m,5m], min_history_bars: {1m: 1200,5m: 600}}]`.
   - Єдине джерело: читають і конектор, і інжестор, і SMC пайплайн; усі споживачі перевіряють `version`.
   - Acceptance: YAML валідований у старті `bootstrap()`, лог про активний контракт.

2) **FXCM-конектор: підпорядкування контракту (M)**
   - Читає contract-of-needs під час старту; стрімить лише потрібні символи/TF; додаткові символи — best-effort без гарантій для SMC.
   - Реалізується в окремому репозиторії `fxcm_connector`; тут описані вимоги/очікування SMC.
   - Warmup на стороні конектора: підтягувати min_history_bars до старту стріму.
   - Acceptance: лог `contract_applied` з переліком (symbol, tf, depth); HMAC/канали без змін.

3) **FXCM інжестор → UnifiedDataStore (M)**
   - Фільтр payload за contract-of-needs: відкидати або складати в короткий буфер сторонні символи/TF (наприклад, останні 10 барів у RAM, без диска); фільтрація до запису в UnifiedDataStore, щоб non-contract символи не займали диск.
   - Метрики: `fxcm_ingest_filtered_total` (reason=not_in_contract), щоб видно було витрати.
   - Acceptance: при стрімі 200 символів у Redis у UnifiedDataStore опиняються лише FXCM_FAST_SYMBOLS/TF з контракту; warn при невідповідності tf.

4) **UnifiedDataStore як робоча пам'ять SMC (M/L)**
   - Профілі TTL/eviction прив'язати до contract-of-needs: для не-універсума — жорстко обрізати TTL до N останніх барів; для fast — гарантувати зберігання min_history_bars + live буфер.
   - Опціональний lightweight bucket для діагностики сторонніх символів (RAM only, no disk, TTL ~10 барів); TTL/eviction для non-contract застосовні лише якщо ми їх тимчасово тримаємо в RAM.
   - Acceptance: snapshot/metrics показують, що не-універсум не займає місця в дискових снапшотах; евікшени не чіпають fast до виконання min_history.

5) **Warmup gate та FSM COLD→WARMUP→LIVE (M)**
   - Додати трекер готовності per (symbol, tf) у SMC-пайплайні: перевірка довжини, дірок, свіжості останнього бара.
   - До LIVE не публікувати SmcHint/ViewerState; UI показує стан warmup/cold; стан COLD/WARMUP/LIVE додається в `viewer_state.meta.pipeline_state`.
   - Acceptance: лог `[WARMUP] symbol=tf готовий, bars=...`; UI_v2 порожній стан означає відсутність LIVE.

6) **Scheduler з бюджетом (M)**
   - Планувальник на черзі задач (symbol, tf) з м'яким лімітом задач/часу (орієнтир 200–400 мс/цикл).
   - Деградація при рості універсуму: зменшення частоти per symbol без дропів LIVE.
   - Acceptance: метрики циклу (`tasks_taken`, `cycle_ms`, `skipped_due_budget`); предиктивне логування при зміні FXCM_FAST_SYMBOLS.

7) **UI_v2 / телеметрія (S)**
   - У payload додати стани FSM (COLD/WARMUP/LIVE) і причину блокування (наприклад, `missing_history`, `stale_last_bar`).
   - Acceptance: ViewerState показує, чому актив не в LIVE; готовність видно без дебаг-логів.

## Ризики й межі

- Stage1/legacy тригери заморожені — зміни тільки в SMC-шарі, інжесторі та datastore.
- Не змінюємо схеми Redis-ключів SMC/UI; нові ключі/значення — лише додаткові поля contract-of-needs і телеметрії.
- Латентність: бюджет 200–400 мс/цикл контролюється scheduler-метриками до впровадження жорстких квантів.

## Черга наступних кроків (мінімум для старту)

1. Додати contract-of-needs у datastore.yaml + валідатор у bootstrap (S).
2. У fxcm_ingestor впровадити фільтр за контрактом та метрику відсіву (M).
3. У UnifiedDataStore додати профіль для non-contract symbols (RAM-only короткий буфер) + TTL-контроль (M).
4. У SMC-пайплайні ввести warmup gate + FSM стани в SmcState/ViewerState (M).
5. Окремим кроком — прототип scheduler із м'яким бюджетом та метриками (M).

Оцінка обсягу: 1×S + 4×M + 1×M/L → ~1.5–2 тижні інкрементами по 1–2 задачі з тестами та телеметрією.
