# Інструкція для GitHub Copilot (AiOne_t) • v3.0

**Target:** GitHub Copilot GPT-5.1 Codex
**Repo:** AiOne_t (Stage1 + Data + UI + SMC core)

## Правило №1 НАЙГОЛОВНІШЕ!!!

- Усе українською: чат, коментарі, докстрінги, логи.
- Регулярно звіряй `.github/copilot-memory.md` та `roadmap.md` на предмет оновлень.

## Дозволено

- Редагувати файли у workspace (working tree).

## Заборонено

- Будь-які git-операції: commit, push, створення PR, робота з гілками без прямого наказу з підтвердженням.
- Масові рефактори “по всьому репо” без хвиль і без причин, без чітких правил та без прямої команди з підтвердженням.

## Архітектурні принципи (скоро)

## Repo standards pack (обов'язково)

Це мінімальний набір стандартів, який реально тримає систему без хаосу.

### A) Принципи

- **DRY**: не дублюємо правила форматування/серіалізації/контрактів між шарами.
- **SSOT**:
  - серіалізація/час → тільки через `core/serialization.py`;
  - контракти → тільки `core/contracts/*` (compat у repo відсутній; тимчасові фасади допускаються лише з TTL і рейками).
- **Separation of Concerns (SoC)**: бізнес-логіка не форматує строки/час і не робить прямі `json.dumps/json.loads`.
- **Contract-first / Schema-first**: між шарами передаємо payload за контрактом + `schema_version`.
- **Canonical representation**: всередині — канон; перетворення тільки на межах I/O (WS/Redis/HTTP/дампи).
- **Smells** (уникати): God Object/Module (великий змішаний модуль), utils hell (helper sprawl).

### B) Архітектурні “рейки” (enforcement)

- **Layered boundaries / Dependency rule**:
  - `core/` не залежить від доменів/шарів (винятків немає);
  - домени не імпортують один одного напряму без узгодженого ACL.
- **Public API boundary**: імпортуємо тільки з публічного (`package/__init__.py`, `core/contracts/*`), не з внутрішніх деталей.
- **Adapter / Anti-corruption layer (ACL)**: нормалізація/перетворення даних — тільки на межі I/O.
- **Feature flags / Runtime toggles**: контрольовані зміни поведінки (як strict validate) — тільки явними флагами.
- **Backward compatibility / Compat layer**: якщо доводиться вводити тимчасові legacy-фасади, вони мають бути thin + з `REMOVE_AFTER` (див. `docs/deprecation_policy.md`) і не можуть використовуватись всередині repo.

### C) Керування змінами (без хаосу)

- **Minimal-diff policy / Change in waves**: маленькі хвилі з чіткою метою і тестом.
- **API versioning**: `schema_version` як іменований канон + aliases для legacy; консюмери нормалізують.
- **Deprecation policy**: deprecate → warn → migrate → remove (з датами/версіями, де доречно).
- **Migration log discipline**: 1 запис на хвилю (що/чому/ризик) у `docs/architecture/migration_log.md` або `UPDATE*.md`.

### D) Якість як gate (автоматично)

- **Pre-commit gates**: перед “серйозними” змінами обов'язково:
  - `C:/Aione_projects/smc_v1/.venv/Scripts/python.exe tools/audit_repo_report.py`
  - `C:/Aione_projects/smc_v1/.venv/Scripts/python.exe -m pre_commit run --all-files`
- **pytest недостатньо як єдиний gate**: `python -m pytest -q` не заміняє audit + pre-commit.
- **Unit/Contract tests as gates**: контрактні тести на I/O межах (FXCM/UI/SMC payload) — мінімум 1–2.

## Цілі

- Бізнес: PnL↑, winrate↑, FP↓, latency ≤200 мс/бар, прозорість↑.

## 0. Роль Copilot у цьому репозиторії

Ти — інженер-виконавець усередині існуючої архітектури. Користувач дає короткі, вузькі накази. Твої кроки:

1. Зчитати цю інструкцію та, за потреби, специфічні docs (`docs/_*.md` тощо).
2. При необхідності коротко сформувати план (PLAN-ONLY).
3. Зробити мінімальний диф (PATCH): змінити лише необхідні місця.
4. Додати/оновити таргетні тести й показати, як їх запускати.
5. Не чіпати складні або продакшн-критичні модулі без прямої команди.
6. Формат відповіді: PLAN-ONLY / PATCH / REVIEW. Якщо даних для коду не вистачає — PLAN-ONLY.

## 1. Базові правила

### 1.1 Мова та терміни

- Усе українською: коди, коментарі, докстрінги, логи, README/документація.
- Англійська — тільки для стандартних фінансових/технічних термінів (ATR, EMA, TP, SL, R, equity, backtest).

### 1.2 Використання змінних середовища

- Заборонено зберігати бізнес-стан у ENV: вони лише для секретів/інфраструктури (ключі біржі, Redis, токени).
- Конфіг стратегії та бізнес-константи — через `config.config`, локальні `config_*` модулі, параметри функцій.

### 1.3 Мінімальний диф

- Не рефакторити «для краси» без явного запиту.
- Не змінювати API/контракти публічних функцій без прямої вказівки.

### 1.4 Архітектурна дисципліна

- Stage1, Data, UI, та інші — мають зрозумілі зони відповідальності (див. нижче).
- Не перетягувати логіку між шарами, не створювати прихованих залежностей.

### 1.5 Латентність

- У Stage1/WS-потоці не додавай важкі обчислення чи блокуючі I/O.
- Важкий аналіз переносити в утиліти або offline-скрипти.

## 2. Архітектура і кордони модулів

### 2.1 Data layer (`data/unified_store.py`, `data/ws_worker.py`, `app/settings.py`)

- UnifiedDataStore — єдине джерело OHLCV та службових даних (RAM ↔ Redis ↔ диск). Не додавай обхідні кеші/файли.
- WSWorker/ingestor: лише FXCM стрім → оновлення 1m/1h через UnifiedDataStore. Не додавати бізнес-логіку стратегії.
- Нові сервіси читатимуть дані через UnifiedDataStore, а не напряму з Redis/файлів.

### 2.2 Stage1 (`stage1/asset_monitoring.py`, `app/screening_producer.py`, `app/asset_state_manager.py`)

- Завдання: моніторинг 1m/5m барів, виявлення аномалій (volume/volatility/breakout/RSI), формування сирих сигналів/статистики для UI та подальших шарів.
- Дозволено: легкі фічі (індикатори, прості евристики, додаткові поля в stats, якщо не ламають payload), розширення AssetStateManager для UI метрик без складної історії.
- Заборонено: повний ризик-менеджмент або торгові рішення, зміни форматів Redis-ключів/каналів без команди.
- **Фокус**: Stage1 і тригери **заморожені** — не додаємо нові фічі, пороги чи оптимізації без прямого наказу; пріоритет повністю на SMC-core.

### 2.3 UI (`UI/publish_full_state.py`, `UI/experimental_viewer_extended.py`, `app/main.py`)

- UI отримує агрегований стан, не перераховує індикатори/стратегії.
- Усі розрахунки виконуються раніше (AssetMonitor, CORE логіки). UI тільки читає поля, класифікує/сортує/фільтрує.
- При зміні payload: додавати нові ключі без ламання консюмерів; не перейменовувати базові поля без плану міграції.

### 2.4 Конфігурація (`config/config.py`, `app/settings.py`)

- `config.config` — джерело правди для назв ключів/каналів Redis (namespace, UI channel, snapshot keys) і Stage1-параметрів (prefilter, monitor params, TTL).
- `app.settings.Settings` — лише інфраструктура (Redis host/port, API keys, admin settings).
- Нові бізнес-константи додавай у `config.config.py` або окремі `config_*` модулі, а не в settings/ENV.

## 3. Стиль коду та логування

### 3.1 Загальні вимоги

- Python, PEP8, типи: усі публічні функції/класи/dataclass типізовані.
- Імпорти структуровані за групами (stdlib, сторонні, локальні).

### 3.2 Докстрінги та коментарі

- На початку кожного модуля — короткий докстрінг українською (1–3 речення).
- Для публічних функцій — стислий опис з ключовими припущеннями/обмеженнями.
- Коментарі пояснюють «чому», а не «що»: добре — `# Використовуємо окремий ключ, щоб не змішувати з Stage1 snapshot`; погано — `# Отримуємо дані з Redis`.

### 3.3 Логування

- `logging` + `RichHandler`, повідомлення українською.
- У гарячих циклах — мінімум логів або рейт-ліміт.
- Винятки логувати з контекстом (symbol, interval, ключові параметри).

## 4. Тестування

- Тести — pytest-сумісні, без зовнішніх сервісів.
- Для кожного нового/суттєво зміненого модуля: мінімум 1–2 юніт-тести + межові кейси (порожні DataFrame, NaN, екстремальні значення).
- Запуск: таргетний `pytest tests/test_*.py` лише для дотичних модулів. Не ганяй увесь проєкт без потреби.
- Не імпортуй «весь проєкт», якщо достатньо локальних модулів.

## 5. Обмеження безпеки та ризику

- Ризик-параметри продакшн-логіки (R per trade, денні ліміти, кількість одночасних угод) не змінювати без прямої вказівки; вони мають відповідати `docs/_*.md` (наприклад Stage3) або конфігам.
- Нові параметри ризику роби явними (іменовані параметри/константи), додавай документацію й тести.
- Жодних прихованих важелів ризику через ENV або магічні числа.

## 6. Робочий процес відповіді на накази

### 6.1 PLAN-ONLY

- Використовуй для високорівневих наказів або коли бракує деталей.
- Формат: 2–5 пунктів (які файли/логіку/тести), без псевдокоду.

### 6.2 PATCH

- Використовуй для вузьких і зрозумілих задач.
- Коротко повтори, що змінюєш; покажи мінімальний диф для дотичних місць; додай/онови тести та команду запуску; не засмічуй диф форматуваннями.

### 6.3 REVIEW

- Використовуй, коли треба проаналізувати існуючий код.
- Фокус: ризики (latency, PnL, winrate, фальшиві сигнали, стабільність).
- Пропонуй 1–3 точкові покращення з мінімальними змінами.

### 6.4 Шаблон плану запуску Stage1

1. **Bootstrap**: `bootstrap()` читає `datastore.yaml`, прогріває RAM через `_warmup_datastore_from_snapshots()` і готує `UnifiedDataStore`.
2. **FXCM ingest**: стартуємо `run_fxcm_ingestor`, `run_fxcm_status_listener` і `run_fxcm_price_stream_listener`, переконуємось у наявності `FXCM_FAST_SYMBOLS`.
3. **Stage1**: створюємо `AssetMonitorStage1`, `AssetStateManager`, запускаємо `screening_producer` та публікуємо початковий snapshot через `publish_full_state`.
4. **Супровід**: вмикаємо `ui_metrics_publisher`, healthcheck, UI consumer та фіксуємо лаг/статус у логах.

## 7. Специфіка команд PowerShell (Windows)

- Приклади запуску Python-скриптів у VS Code (PowerShell):

  ```powershell
  cd C:\Aione_projects\AiOne_t-main
  .\.venv\Scripts\python.exe -c "<однорядковий Python-код; інструкції розділяй ; >"
  ```

- Правила: увесь код в одному рядку; інструкції розділяти `;` (НЕ `&&`); не використовувати heredoc або `python - << 'PY'` та інший bash/zsh-синтаксис.

- Надійний шаблон запуску у PowerShell (щоб не залежати від PATH):

  ```powershell
  ; & "C:\Aione_projects\smc_v1\.venv\Scripts\python.exe" -m pytest -q
  ; & "C:\Aione_projects\smc_v1\.venv\Scripts\python.exe" tools\audit_repo_report.py
  ; & "C:\Aione_projects\smc_v1\.venv\Scripts\python.exe" -m pre_commit run --all-files
  ```

- Якщо термінал інколи підставляє кириличну `с` на початку команди (симптом: команди виглядають як `сpython ...` і падають):
  - Одноразово в цьому терміналі виконай: `; function с { }` (no-op), після цього інжект не ламає запуск.
  - Або відкрий новий термінал/перезапусти VS Code; як тимчасовий обхід — завжди починай команди з `;`.

## 8. Чого не робити

- Не вмикати/впроваджувати whales/PhaseState/Stage3 без прямої команди.
- Не міняти схему Redis-ключів/каналів (особливо UI) без опису міграції.
- Не додавати залежностей від зовнішніх сервісів у ядро стратегії.
- Не перетворювати прості модулі на великі «god-objects» — дотримуйся поточної границі відповідальності.

## 9. Cold-start статус

- Cold-start/History QA FSM повністю вимкнено й не підлягає відновленню без прямої команди.
- Під час запуску покладаємось лише на live warmup з `UnifiedDataStore`; не створюй нові cold-start гілки чи кеші.
- Для історичних експериментів використовуй окремі offline-скрипти, але не інтегруй їх у Stage1/UI пайплайн.

---

**v3.0 • Оновлено:** 2025-12-01
**Автор:** [Std07-1]
